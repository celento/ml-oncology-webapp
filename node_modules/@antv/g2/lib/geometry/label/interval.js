"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var base_1 = tslib_1.__importDefault(require("./base"));
/**
 * 柱状图 label
 */
var IntervalLabel = /** @class */ (function (_super) {
    tslib_1.__extends(IntervalLabel, _super);
    function IntervalLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {
        var coordinate = this.coordinate;
        var transposed = coordinate.isTransposed;
        var shapePoints = mappingData.points;
        var point0 = coordinate.convert(shapePoints[0]);
        var point1 = coordinate.convert(shapePoints[2]);
        var width = ((point0.x - point1.x) / 2) * (transposed ? -1 : 1);
        var height = ((point0.y - point1.y) / 2) * (transposed ? -1 : 1);
        switch (position) {
            case 'right':
                if (transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y += height;
                    labelPointCfg.textAlign = labelPointCfg.textAlign || 'center';
                }
                else {
                    labelPointCfg.x -= width;
                    labelPointCfg.y += height;
                    labelPointCfg.textAlign = labelPointCfg.textAlign || 'left';
                }
                break;
            case 'left':
                if (transposed) {
                    labelPointCfg.x -= width;
                    labelPointCfg.y -= height;
                    labelPointCfg.textAlign = labelPointCfg.textAlign || 'center';
                }
                else {
                    labelPointCfg.x += width;
                    labelPointCfg.y += height;
                    labelPointCfg.textAlign = labelPointCfg.textAlign || 'right';
                }
                break;
            case 'bottom':
                if (transposed) {
                    labelPointCfg.x -= width * 2;
                    labelPointCfg.textAlign = labelPointCfg.textAlign || 'left';
                }
                else {
                    labelPointCfg.y += height * 2;
                    labelPointCfg.textAlign = labelPointCfg.textAlign || 'center';
                }
                break;
            case 'middle':
                if (transposed) {
                    labelPointCfg.x -= width;
                }
                else {
                    labelPointCfg.y += height;
                }
                labelPointCfg.textAlign = labelPointCfg.textAlign || 'center';
                break;
            case 'top':
                if (transposed) {
                    labelPointCfg.textAlign = labelPointCfg.textAlign || 'left';
                }
                else {
                    labelPointCfg.textAlign = labelPointCfg.textAlign || 'center';
                }
                break;
            default:
                break;
        }
    };
    return IntervalLabel;
}(base_1.default));
exports.default = IntervalLabel;
//# sourceMappingURL=interval.js.map