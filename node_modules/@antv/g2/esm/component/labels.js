import { __assign } from "tslib";
import { deepMix, each, get, isArray } from '@antv/util';
import { doAnimate } from '../animate';
import { getGeometryLabelLayout } from '../geometry/label';
import { getReplaceAttrs } from '../util/graphics';
import { rotate, translate } from '../util/transform';
/**
 * Geometry labels 渲染组件
 */
var Labels = /** @class */ (function () {
    function Labels(cfg) {
        /** 存储当前 shape 的映射表，键值为 shape id */
        this.shapesMap = {};
        this.lastShapesMap = {};
        var layout = cfg.layout, container = cfg.container;
        this.layout = layout;
        this.container = container;
    }
    /**
     * 渲染文本
     */
    Labels.prototype.render = function (items, shapes, isUpdate) {
        var _this = this;
        if (isUpdate === void 0) { isUpdate = false; }
        this.shapesMap = {};
        var container = this.container;
        var offscreenGroup = this.createOffscreenGroup(); // 创建虚拟分组
        // 在虚拟 group 中创建 shapes
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            if (item) {
                this.renderLabel(item, offscreenGroup);
            }
        }
        this.adjustLabels(shapes, items); // 调整 labels
        // 进行添加、更新、销毁操作
        var lastShapesMap = this.lastShapesMap;
        var shapesMap = this.shapesMap;
        each(shapesMap, function (shape, id) {
            if (shape.destroyed) {
                // label 在布局调整环节被删除了（adjustLabels）
                delete shapesMap[id];
            }
            else {
                if (lastShapesMap[id]) {
                    // 图形发生更新
                    var data_1 = shape.get('data');
                    var origin_1 = shape.get('origin');
                    var coordinate_1 = shape.get('coordinate');
                    var currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape
                    var currentAnimateCfg_1 = shape.get('animateCfg');
                    currentShape.set('data', data_1);
                    currentShape.set('origin', origin_1);
                    currentShape.set('animateCfg', currentAnimateCfg_1);
                    currentShape.set('coordinate', coordinate_1);
                    var updateAnimateCfg_1 = get(currentAnimateCfg_1, 'update');
                    var currentChildren_1 = currentShape.getChildren();
                    shape.getChildren().map(function (child, index) {
                        var currentChild = currentChildren_1[index];
                        currentChild.set('data', data_1);
                        currentChild.set('origin', origin_1);
                        currentChild.set('animateCfg', currentAnimateCfg_1);
                        currentChild.set('coordinate', coordinate_1);
                        var newAttrs = getReplaceAttrs(currentChild, child);
                        if (updateAnimateCfg_1) {
                            doAnimate(currentChild, updateAnimateCfg_1, {
                                toAttrs: newAttrs,
                                coordinate: coordinate_1,
                            });
                        }
                        else {
                            currentChild.attr(newAttrs);
                        }
                    });
                    _this.shapesMap[id] = currentShape; // 保存引用
                }
                else {
                    // 新生成的 shape
                    container.add(shape);
                    var animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');
                    if (animateCfg) {
                        doAnimate(shape, animateCfg, {
                            toAttrs: __assign({}, shape.attr()),
                            coordinate: shape.get('coordinate'),
                        });
                    }
                }
                delete lastShapesMap[id];
            }
        });
        // 移除
        each(lastShapesMap, function (deleteShape) {
            var animateCfg = get(deleteShape.get('animateCfg'), 'leave');
            if (animateCfg) {
                doAnimate(deleteShape, animateCfg, {
                    toAttrs: null,
                    coordinate: deleteShape.get('coordinate'),
                });
            }
            else {
                deleteShape.remove(true); // 移除
            }
        });
        this.lastShapesMap = shapesMap;
        offscreenGroup.destroy();
    };
    /** 清楚当前 labels */
    Labels.prototype.clear = function () {
        this.container.clear();
        this.shapesMap = {};
        this.lastShapesMap = {};
    };
    /** 销毁 */
    Labels.prototype.destroy = function () {
        this.container.destroy();
        this.shapesMap = null;
        this.lastShapesMap = null;
    };
    Labels.prototype.renderLabel = function (cfg, container) {
        var id = cfg.id, data = cfg.data, mappingData = cfg.mappingData, coordinate = cfg.coordinate, animate = cfg.animate, content = cfg.content, offset = cfg.offset;
        var shapeAppendCfg = {
            id: id,
            data: data,
            origin: mappingData,
            coordinate: coordinate,
        };
        var labelGroup = container.addGroup(__assign({ name: 'label', 
            // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并
            animateCfg: this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate) }, shapeAppendCfg));
        var labelShape;
        if ((content.isGroup && content.isGroup()) || (content.isShape && content.isShape())) {
            // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup
            var _a = content.getCanvasBBox(), width = _a.width, height = _a.height;
            var textAlign = cfg.textAlign || 'left';
            var x = cfg.x;
            var y = cfg.y - (height / 2);
            if (textAlign === 'center') {
                x = x - (width / 2);
            }
            else if (textAlign === 'right' || textAlign === 'end') {
                x = x - width;
            }
            translate(content, x, y); // 将 label 平移至 x, y 指定的位置
            labelShape = content;
            labelGroup.add(content);
        }
        else {
            labelShape = labelGroup.addShape('text', __assign({ attrs: __assign({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, text: cfg.content }, cfg.style) }, shapeAppendCfg));
        }
        if (cfg.rotate) {
            rotate(labelShape, cfg.rotate);
        }
        this.drawLabelLine(cfg, labelGroup);
        this.shapesMap[id] = labelGroup;
    };
    // 根据type对label布局
    Labels.prototype.adjustLabels = function (shapes, items) {
        var _this = this;
        if (this.layout) {
            var layouts = isArray(this.layout) ? this.layout : [this.layout];
            each(layouts, function (layout) {
                var layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));
                if (layoutFn) {
                    var labelShapes_1 = [];
                    var geometryShapes_1 = [];
                    each(_this.shapesMap, function (labelShape, id) {
                        labelShapes_1.push(labelShape);
                        geometryShapes_1.push(shapes[id]);
                    });
                    layoutFn(labelShapes_1, geometryShapes_1, items, _this.region, layout.cfg);
                }
            });
        }
    };
    Labels.prototype.drawLabelLine = function (labelCfg, container) {
        if (!labelCfg.labelLine) {
            // labelLine: null | false，关闭 label 对应的 labelLine
            return;
        }
        var labelLineCfg = get(labelCfg, 'labelLine', {});
        var path = labelLineCfg.path;
        if (!path) {
            var start = labelCfg.start;
            path = [
                ['M', start.x, start.y],
                ['L', labelCfg.x, labelCfg.y],
            ];
        }
        container.addShape('path', {
            capture: false,
            attrs: __assign({ path: path, stroke: labelCfg.color ? labelCfg.color : get(labelCfg, ['style', 'fill'], '#000'), fill: null }, labelLineCfg.style),
            id: labelCfg.id,
            origin: labelCfg.mappingData,
            data: labelCfg.data,
            coordinate: labelCfg.coordinate,
        });
    };
    Labels.prototype.createOffscreenGroup = function () {
        var container = this.container;
        var GroupClass = container.getGroupBase(); // 获取分组的构造函数
        var newGroup = new GroupClass({});
        return newGroup;
    };
    return Labels;
}());
export default Labels;
//# sourceMappingURL=labels.js.map